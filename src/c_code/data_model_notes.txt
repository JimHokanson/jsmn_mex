Data Model
----------
Following is a description of the internal data model used during parsing.


Tokens include:
Object  {
Array   [
Key     :
String  "
Number  1
Null    null  - I represent null as NaN
True    true
False   false

Things that exist for every token.
----------------------------------
Values in these arrays are ordered as they are encountered in the JSON string.
In other words, the first value in the array corresponds to the first token.

Note that from these definitions that every token takes up at least 9 bytes.

types : array of uint8
    Indicates the type of token. See values in turtle_json.h

d1 : array of int32
        d1 is either:
        1) The # of entries something contains
        2) An index of the element in a vector of elements of that type

    object: # of keys in object
     array: # of values in the array (i.e. length of the array)
    string: 1 based index of the string element that this token occupies
            in other words, this is equivalent to the # of strings 
            observed so far, including this one. Use this to index into
            'strings'
       key: same as string definition, but for 'keys' property
    number: same as string definition, but for 'numeric_p' property
      null: same as string definition, but for 'numeric_p' property
      true: not used, value is undefined
     false: not used, value is undefined


d2 : array of int32
        d2 is either:

    object: index of token after the object closes (1 based)
     array: "    " array closes
       key: "    " key value closes, e.g. {"key": [1,2,3,4], 
                     "next_key" ... <= index of "key" points to "next_key"
                     token
    string:  not used, value is undefined (TODO: might make this a length)
    number:  "    "
      null:  "    "
      true:  "    "
     false:  "    "

Data Type Specific
------------------

    --------  Key Related -------
            keys : cellstr
                Parsed key strings
            key_p: array of unsigned char *
                Pointer to the first character in the key string (not the 
                opening double quotes)

        TODO: These might change since the processing approach changed
        ---------------------------
        A better approach now might be to keep track of the # of characters
        in the entry, since key_p is a sufficient pointer

key_start_indices: array of int
            Count of the # of key characters at the start of processing
            this key. This is used for placing all keys into a singular
            array.
  key_end_indices: array of int
            Count of the # of key characters (really bytes) after initial
            processing of the key. This gets updated in post-processing
            based on UTF8 processing (conversion to UTF16).
    
    -------- String Related -------
        strings: cellstr
            Parsed string values    
       string_p: array of unsigned char *
            Pointer to the first character in the key string (not the 
            opening double quotes)

TODO: See note in key section regarding these values. Since d2 is unused
it could possibly store the length.
string_end_indices:
string_start_indices:

    -------  Number Related  ------
      numeric_p: 1) Initially a pointer to the start of a number to process
                 2) Later this takes on the 

General Meta Data
----------------------
          n_key_chars: total # of bytes in the JSON string that are part 
            of keys (not including double quotes)
       n_string_chars: same as 'n_key_chars' but for string values
    n_key_allocations:
 n_string_allocations:
n_numeric_allocations:

